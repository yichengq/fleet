package registry

import (
	"errors"
	"io/ioutil"
	"os/user"
	"path/filepath"
	"strings"

	gossh "github.com/coreos/fleet/third_party/code.google.com/p/go.crypto/ssh"

	"github.com/coreos/fleet/ssh"
)

const (
	DefaultAuthorizedKeyFile = "~/.ssh/authorized_keys"
)

var (
	signingPrefix     = "/signing/"
	AuthorizedKeyFile = DefaultAuthorizedKeyFile
)

// CreateSigning creates signing for key/value pair on etcd
func (r *Registry) CreateSigning(key, value string) error {
	sigKey := buildSigningKey(key)

	signs, err := r.createSigns(valueForSign(key, value))
	if err != nil {
		return err
	}

	sigValue, err := marshal(signs)
	if err != nil {
		return err
	}

	_, err = r.etcd.Create(sigKey, sigValue, 0)
	return err
}

// DestroySigning deletes signing for key from etcd
func (r *Registry) DestroySigning(key string) {
	sigKey := buildSigningKey(key)
	r.etcd.Delete(sigKey, false)
}

// VerifySigning verifies whether or not value fits its signing
func (r *Registry) VerifySigning(key, value string) (bool, error) {
	sigKey := buildSigningKey(key)

	resp, err := r.etcd.Get(sigKey, false, true)
	if err != nil {
		return false, err
	}

	var signs [][]byte
	// TODO: Handle the error generated by unmarshal
	unmarshal(resp.Node.Value, &signs)

	return r.verifySigns(valueForSign(key, value), signs)
}

func (r *Registry) loadAuthorizedKeys(filepath string) error {
	out, err := ioutil.ReadFile(filepath)
	if err != nil {
		return err
	}

	r.authKeys = make([]gossh.PublicKey, 0)
	for len(out) > 0 {
		pubkey, _, _, rest, ok := gossh.ParseAuthorizedKey(out)
		if !ok {
			return errors.New("fail to parse authorized key file")
		}
		out = rest

		r.authKeys = append(r.authKeys, pubkey)
	}

	return nil
}

func (r *Registry) createSigns(data []byte) ([][]byte, error) {
	if r.keyring == nil {
		var err error
		if r.keyring, err = ssh.NewSSHAgentKeyring(); err != nil {
			return nil, err
		}
	}

	sigs := make([][]byte, 0)
	// Generate all possible signatures
	for i := 0; ; i++ {
		sig, err := r.keyring.Sign(i, nil, data)
		if err == ssh.ErrKeyOutofIndex {
			break
		}
		if err != nil {
			return nil, err
		}
		sigs = append(sigs, sig)
	}
	return sigs, nil
}

func (r *Registry) verifySigns(data []byte, signs [][]byte) (bool, error) {
	if r.authKeys == nil {
		filepath, err := parseFilepath(AuthorizedKeyFile)
		if err != nil {
			return false, err
		}

		if err = r.loadAuthorizedKeys(filepath); err != nil {
			return false, err
		}
	}

	// Enumerate all pairs to verify signatures
	for _, authKey := range r.authKeys {
		for _, sign := range signs {
			if authKey.Verify(data, sign) {
				return true, nil
			}
		}
	}

	return false, nil
}

func buildSigningKey(key string) string {
	key = strings.TrimPrefix(key, keyPrefix)
	return filepath.Join(keyPrefix, signingPrefix, key)
}

// use the concatenation of key and value to protect both
func valueForSign(key, value string) []byte {
	return []byte(key + value)
}

// get absolute file path considering user home directory
func parseFilepath(path string) (string, error) {
	usr, err := user.Current()
	if err != nil {
		return "", err
	}
	path = strings.Replace(path, "~", usr.HomeDir, 1)

	path, err = filepath.Abs(path)
	return path, err
}
